import {
	useCallback,
	useEffect,
	useEffectEvent,
	useLayoutEffect,
	useRef,
} from "react";
import { useFps, useTimelineStore } from "@/editor/contexts/TimelineContext";
import { framesToSeconds, framesToTimecode } from "@/utils/timecode";
import { createModelSelector } from "../model/registry";
import type { TimelineProps } from "../model/types";
import {
	calculateVideoTime,
	type VideoClipInternal,
	type VideoClipProps,
} from "./model";
import { getThumbnail, getVideoSize } from "./thumbnailCache";

interface VideoClipTimelineProps extends TimelineProps {
	id: string;
}

const useVideoClipSelector = createModelSelector<
	VideoClipProps,
	VideoClipInternal
>();

export const VideoClipTimeline: React.FC<VideoClipTimelineProps> = ({
	id,
	start,
	end,
}) => {
	const { fps } = useFps();
	const canvasRef = useRef<HTMLCanvasElement>(null);
	const renderTokenRef = useRef(0);
	const lastRenderKeyRef = useRef("");
	const lastUriRef = useRef<string | null>(null);
	const scheduleIdRef = useRef<number | null>(null);

	// 订阅 model 状态
	const uri = useVideoClipSelector(id, (state) => state.props.uri);
	const reversed = useVideoClipSelector(id, (state) => state.props.reversed);
	const maxDuration = useVideoClipSelector(
		id,
		(state) => state.constraints.maxDuration,
	);
	const element = useTimelineStore((state) => state.getElementById(id));

	const isLoading = useVideoClipSelector(
		id,
		(state) => state.constraints.isLoading ?? false,
	);

	// 从 Model 获取 videoSink 和 duration
	const videoSink = useVideoClipSelector(
		id,
		(state) => state.internal.videoSink,
	);
	const input = useVideoClipSelector(id, (state) => state.internal.input);
	const videoDuration = useVideoClipSelector(
		id,
		(state) => state.internal.videoDuration,
	);

	const getVideoSink = useEffectEvent(() => videoSink);
	const getInput = useEffectEvent(() => input);

	const clipDurationFrames = end - start;
	const clipDurationSeconds = framesToSeconds(clipDurationFrames, fps);
	const timelineOffsetFrames = useTimelineStore(
		(state) => state.getElementById(id)?.timeline?.offset ?? 0,
	);
	const offsetSeconds = framesToSeconds(timelineOffsetFrames, fps);
	const scrollLeft = useTimelineStore((state) => state.scrollLeft);

	// 生成预览图（使用全局缓存）
	const generateThumbnails = useCallback(async () => {
		if (
			!canvasRef.current ||
			!uri ||
			videoDuration <= 0 ||
			clipDurationSeconds <= 0
		) {
			return;
		}

		const canvas = canvasRef.current;
		const ctx = canvas.getContext("2d");
		if (!ctx) return;

		let canvasWidth = 0;
		let canvasHeight = 0;
		let pixelRatio = 1;

		try {
			const rect = canvas.getBoundingClientRect();
			const viewport = canvas.closest(
				"[data-timeline-scroll-area]",
			) as HTMLElement | null;
			const viewportRect = viewport ? viewport.getBoundingClientRect() : rect;

			const visibleLeft = Math.max(rect.left, viewportRect.left);
			const visibleRight = Math.min(rect.right, viewportRect.right);
			const visibleTop = Math.max(rect.top, viewportRect.top);
			const visibleBottom = Math.min(rect.bottom, viewportRect.bottom);
			if (visibleRight <= visibleLeft || visibleBottom <= visibleTop) {
				return;
			}

			canvasWidth = rect.width;
			canvasHeight = rect.height;
			if (canvasWidth <= 0 || canvasHeight <= 0) {
				return;
			}

			pixelRatio = Math.max(1, window.devicePixelRatio || 1);
			const targetWidth = Math.max(1, Math.floor(canvasWidth * pixelRatio));
			const targetHeight = Math.max(1, Math.floor(canvasHeight * pixelRatio));
			let snapshotCanvas: HTMLCanvasElement | null = null;
			if (canvas.width !== targetWidth || canvas.height !== targetHeight) {
				if (canvas.width > 0 && canvas.height > 0) {
					snapshotCanvas = document.createElement("canvas");
					snapshotCanvas.width = canvas.width;
					snapshotCanvas.height = canvas.height;
					const snapshotCtx = snapshotCanvas.getContext("2d");
					if (snapshotCtx) {
						snapshotCtx.drawImage(canvas, 0, 0);
					}
				}
				canvas.width = targetWidth;
				canvas.height = targetHeight;
			}
			// 兼容高 DPI，绘制仍使用 CSS 像素
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			ctx.scale(pixelRatio, pixelRatio);
			if (snapshotCanvas) {
				// 尺寸变化时先铺一层旧画面，避免缩放闪白
				ctx.drawImage(
					snapshotCanvas,
					0,
					0,
					snapshotCanvas.width,
					snapshotCanvas.height,
					0,
					0,
					canvasWidth,
					canvasHeight,
				);
			}

			const currentVideoSink = getVideoSink();
			const currentInput = getInput();
			// 使用素材实际比例计算预览图尺寸
			const videoSize = await getVideoSize(uri, currentVideoSink);
			const sourceAspectRatio =
				videoSize && videoSize.height > 0
					? videoSize.width / videoSize.height
					: 16 / 9;

			const thumbnailHeight = canvasHeight;
			const thumbnailWidth = Math.max(1, thumbnailHeight * sourceAspectRatio);
			const numThumbnails = Math.max(
				1,
				Math.ceil(canvasWidth / thumbnailWidth),
			);
			const previewInterval = clipDurationSeconds / numThumbnails;

			const visibleStartX = Math.max(0, visibleLeft - rect.left);
			const visibleEndX = Math.min(canvasWidth, visibleRight - rect.left);
			const overscan = thumbnailWidth * 2;
			const renderStartX = Math.max(0, visibleStartX - overscan);
			const renderEndX = Math.min(canvasWidth, visibleEndX + overscan);
			const startIndex = Math.max(0, Math.floor(renderStartX / thumbnailWidth));
			const endIndex = Math.min(
				numThumbnails - 1,
				Math.ceil(renderEndX / thumbnailWidth) - 1,
			);

			const hasSink = Boolean(currentVideoSink);
			const hasInput = Boolean(currentInput);
			const renderKey = [
				uri,
				clipDurationFrames,
				offsetSeconds,
				reversed ? 1 : 0,
				`${canvasWidth}x${canvasHeight}`,
				pixelRatio,
				hasSink ? 1 : 0,
				hasInput ? 1 : 0,
				`${startIndex}-${endIndex}`,
			].join("|");
			if (renderKey === lastRenderKeyRef.current) {
				return;
			}

			const currentToken = ++renderTokenRef.current;
			let didDraw = false;

			// 按间隔提取帧并绘制（仅渲染可见区域）
			for (let i = startIndex; i <= endIndex; i++) {
				if (renderTokenRef.current !== currentToken) return;
				const relativeTime = i * previewInterval;

				const absoluteTime = calculateVideoTime({
					start: 0,
					timelineTime: relativeTime,
					videoDuration: videoDuration,
					reversed,
					offset: offsetSeconds,
					clipDuration: clipDurationSeconds,
				});

				try {
					const clampedTime = Math.min(
						Math.max(0, absoluteTime),
						Math.max(0, videoDuration - 0.001),
					);
					const timeKey = Math.max(0, Math.round(clampedTime * 1000));
					const thumbnail = await getThumbnail({
						uri,
						time: clampedTime,
						timeKey,
						width: thumbnailWidth,
						height: thumbnailHeight,
						pixelRatio,
						videoSink: currentVideoSink,
						input: currentInput,
						preferKeyframes: true,
					});
					if (renderTokenRef.current !== currentToken) return;
					if (!thumbnail) continue;
					const x = i * thumbnailWidth;
					ctx.drawImage(
						thumbnail,
						0,
						0,
						thumbnail.width,
						thumbnail.height,
						x,
						0,
						thumbnailWidth,
						thumbnailHeight,
					);
					didDraw = true;
				} catch (err) {
					console.warn(`Failed to extract frame at ${absoluteTime}:`, err);
				}
			}
			if (didDraw) {
				lastRenderKeyRef.current = renderKey;
			}
		} catch (err) {
			console.error("Failed to generate thumbnails:", err);
			if (ctx) {
				const errorWidth = canvasWidth || canvas.width / pixelRatio;
				const errorHeight = canvasHeight || canvas.height / pixelRatio;
				ctx.setTransform(1, 0, 0, 1, 0, 0);
				ctx.scale(pixelRatio, pixelRatio);
				ctx.fillStyle = "#fee2e2";
				ctx.fillRect(0, 0, errorWidth, errorHeight);
				ctx.fillStyle = "#dc2626";
				ctx.font = "12px sans-serif";
				ctx.textAlign = "center";
				ctx.fillText(
					"Video Thumbnails Generation Failed",
					errorWidth / 2,
					errorHeight / 2,
				);
			}
		}
	}, [
		videoDuration,
		uri,
		reversed,
		clipDurationSeconds,
		clipDurationFrames,
		offsetSeconds,
	]);

	const scheduleGenerate = useCallback(() => {
		if (scheduleIdRef.current !== null) {
			cancelAnimationFrame(scheduleIdRef.current);
			scheduleIdRef.current = null;
		}
		scheduleIdRef.current = requestAnimationFrame(() => {
			scheduleIdRef.current = null;
			void generateThumbnails();
		});
	}, [generateThumbnails]);

	useEffect(() => {
		if (lastUriRef.current !== uri) {
			lastUriRef.current = uri ?? null;
			lastRenderKeyRef.current = "";
		}
		scheduleGenerate();
	}, [
		uri,
		reversed,
		clipDurationSeconds,
		offsetSeconds,
		videoDuration,
		input,
		scrollLeft,
		scheduleGenerate,
	]);

	useLayoutEffect(() => {
		const canvas = canvasRef.current;
		if (!canvas) return;
		const observer = new ResizeObserver(() => {
			scheduleGenerate();
		});
		observer.observe(canvas);
		return () => observer.disconnect();
	}, [scheduleGenerate]);

	useEffect(() => {
		const handleResize = () => scheduleGenerate();
		window.addEventListener("resize", handleResize, { passive: true });
		return () => window.removeEventListener("resize", handleResize);
	}, [scheduleGenerate]);

	useEffect(() => {
		const scrollArea = document.querySelector<HTMLElement>(
			"[data-vertical-scroll-area]",
		);
		if (!scrollArea) return;
		const handleScroll = () => scheduleGenerate();
		scrollArea.addEventListener("scroll", handleScroll, { passive: true });
		return () => scrollArea.removeEventListener("scroll", handleScroll);
	}, [scheduleGenerate]);

	useEffect(() => {
		return () => {
			if (scheduleIdRef.current !== null) {
				cancelAnimationFrame(scheduleIdRef.current);
				scheduleIdRef.current = null;
			}
		};
	}, []);

	return (
		<div className="absolute inset-0 overflow-hidden bg-zinc-700">
			<div className="absolute inset-x-0 top-0 px-1 pt-px items-center truncate leading-none">
				{element?.name}
			</div>

			{/* 最大时长指示器 */}
			{/* {maxDuration !== undefined && clipDurationFrames > maxDuration && (
				<div
					className="absolute top-0 bottom-0 bg-red-500/30 border-l-2 border-red-500 z-10"
					style={{
						left: `${(maxDuration / clipDurationFrames) * 100}%`,
						right: 0,
					}}
				>
					<div className="absolute top-1 right-1 px-1 rounded bg-red-500 text-white text-xs">
						Exceeds max
					</div>
				</div>
			)} */}

			{/* Loading 指示器 */}
			{isLoading && (
				<div className="absolute inset-0 flex items-center justify-center bg-gray-200/50 z-10">
					<div className="text-xs text-gray-500">Loading...</div>
				</div>
			)}

			{/* 缩略图 canvas */}
			<div className="absolute inset-y-4 w-full">
				<canvas ref={canvasRef} className="absolute inset-0 size-full" />
			</div>
			<div className="absolute inset-x-0 bottom-0 h-4 bg-neutral-700/20"></div>
		</div>
	);
};
