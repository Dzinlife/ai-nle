import { useDrag } from "@use-gesture/react";
import React, {
	startTransition,
	useCallback,
	useEffect,
	useMemo,
	useRef,
	useState,
} from "react";
import { toast } from "sonner";
import { ProgressiveBlur } from "@/components/ui/progressive-blur";
import type { TimelineElement as TimelineElementType } from "@/dsl/types";
import TimeIndicatorCanvas from "@/editor/components/TimeIndicatorCanvas";
import { cn } from "@/lib/utils";
import { clampFrame, framesToTimecode } from "@/utils/timecode";
import TimelineDragOverlay from "./components/TimelineDragOverlay";
import TimelineElement from "./components/TimelineElement";
import TimelineRuler from "./components/TimelineRuler";
import TimelineToolbar from "./components/TimelineToolbar";
import TimelineTrackSidebarItem from "./components/TimelineTrackSidebarItem";
import {
	useAttachments,
	useAutoScroll,
	useCurrentTime,
	useDragging,
	useElements,
	useFps,
	useMainTrackMagnet,
	useMultiSelect,
	usePlaybackControl,
	usePreviewAxis,
	usePreviewTime,
	useSnap,
	useTimelineScale,
	useTimelineStore,
	useTrackAssignments,
	useTracks,
} from "./contexts/TimelineContext";
import { useDragStore } from "./drag";
import {
	calculateAutoScrollSpeed,
	type MaterialDragData,
} from "./drag/dragStore";
import {
	findTimelineDropTargetFromScreenPosition,
	getTimelineDropTimeFromScreenX,
} from "./drag/timelineDropTargets";
import { TRACK_CONTENT_GAP } from "./timeline/trackConfig";
import {
	getFallbackVideoMetadata,
	isVideoFile,
	readVideoMetadata,
	writeVideoToOpfs,
} from "./utils/externalVideo";
import {
	finalizeTimelineElements,
	insertElementIntoMainTrack,
} from "./utils/mainTrackMagnet";
import { getPixelsPerFrame } from "./utils/timelineScale";
import { buildTimelineMeta, updateElementTime } from "./utils/timelineTime";
import {
	buildTrackLayout,
	getTrackHeightByRole,
} from "./utils/trackAssignment";
import { reconcileTransitions } from "./utils/transitions";

const formatTimecode = (frames: number, fps: number) => {
	return framesToTimecode(frames, fps);
};

const normalizeOffsetFrames = (value: unknown): number => {
	if (!Number.isFinite(value as number)) return 0;
	return Math.max(0, Math.round(value as number));
};

const shouldUpdateOffset = (element: TimelineElementType): boolean => {
	return element.type === "VideoClip" || element.type === "AudioClip";
};

const LOCKED_TRACK_OVERLAY_STYLE: React.CSSProperties = {
	backgroundImage:
		"linear-gradient(135deg, rgba(255, 255, 255, 0.16) 25%, rgba(255, 255, 255, 0) 25%, rgba(255, 255, 255, 0) 50%, rgba(255, 255, 255, 0.16) 50%, rgba(255, 255, 255, 0.16) 75%, rgba(255, 255, 255, 0) 75%, rgba(255, 255, 255, 0))",
	backgroundSize: "6px 6px",
};

const applyOffsetDelta = (
	element: TimelineElementType,
	offsetDelta?: number,
): TimelineElementType => {
	if (!offsetDelta) return element;
	if (!shouldUpdateOffset(element)) return element;
	const currentOffset = normalizeOffsetFrames(element.timeline.offset);
	const nextOffset = Math.max(0, currentOffset + offsetDelta);
	if (nextOffset === currentOffset) return element;
	return {
		...element,
		timeline: {
			...element.timeline,
			offset: nextOffset,
		},
	};
};

const TimelineEditor = () => {
	const setCurrentTime = useTimelineStore((state) => state.setCurrentTime);
	const scrollLeft = useTimelineStore((state) => state.scrollLeft);
	const setScrollLeft = useTimelineStore((state) => state.setScrollLeft);
	const { setPreviewTime } = usePreviewTime();
	const { previewAxisEnabled } = usePreviewAxis();
	const { isPlaying } = usePlaybackControl();
	const { currentTime } = useCurrentTime();
	const { fps } = useFps();
	const { timelineScale } = useTimelineScale();
	const { elements, setElements } = useElements();
	const { selectedIds, deselectAll, setSelection } = useMultiSelect();
	const { activeSnapPoint } = useSnap();
	const { trackAssignments, trackCount } = useTrackAssignments();
	const {
		tracks,
		toggleTrackHidden,
		toggleTrackLocked,
		toggleTrackMuted,
		toggleTrackSolo,
	} = useTracks();
	const { activeDropTarget, dragGhosts, isDragging } = useDragging();
	const { autoScrollSpeed, autoScrollSpeedY } = useAutoScroll();
	const { attachments, autoAttach } = useAttachments();
	const { mainTrackMagnetEnabled } = useMainTrackMagnet();
	const trackLockedMap = useMemo(() => {
		return new Map(
			tracks.map((track, index) => [index, track.locked ?? false]),
		);
	}, [tracks]);
	const deleteSelectedElements = useCallback(() => {
		if (selectedIds.length === 0) return;
		setElements((prev) => {
			const nextElements = prev.filter((el) => !selectedIds.includes(el.id));
			if (nextElements.length === prev.length) return prev;
			// 删除 clip 后需要清理失效的转场
			return reconcileTransitions(nextElements, fps);
		});
		deselectAll();
	}, [selectedIds, setElements, deselectAll, fps]);

	const mainTrackMagnetRef = useRef(mainTrackMagnetEnabled);

	// 滚动位置 refs
	const containerRef = useRef<HTMLDivElement>(null);
	const scrollAreaRef = useRef<HTMLDivElement>(null);
	const verticalScrollRef = useRef<HTMLDivElement>(null);
	const scrollLeftRef = useRef(0);
	const touchStartXRef = useRef(0);
	const isSelectingRef = useRef(false);
	const selectionAdditiveRef = useRef(false);
	const initialSelectedIdsRef = useRef<string[]>([]);
	const selectionStartRef = useRef<{ x: number; y: number } | null>(null);
	const selectionActivatedRef = useRef(false);
	const timeStampsRef = useRef<HTMLDivElement>(null);
	const isRulerDraggingRef = useRef(false);
	const lastHoverRef = useRef<{
		clientX: number;
		clientY: number;
		rectLeft: number;
		rectRight: number;
		rectTop: number;
		rectBottom: number;
	} | null>(null);
	const wasDraggingRef = useRef(false);
	const externalDragActiveRef = useRef(false);
	const externalDragOffsetRef = useRef({ x: 0, y: 0 });

	// 左侧列宽度状态
	const [leftColumnWidth] = useState(172); // 默认 44 * 4 = 176px (w-44)

	// 时间刻度尺宽度
	const [rulerWidth, setRulerWidth] = useState(800);
	const observerRef = useRef<ResizeObserver | null>(null);
	const [selectionRect, setSelectionRect] = useState({
		visible: false,
		x1: 0,
		y1: 0,
		x2: 0,
		y2: 0,
	});
	const selectionRectRef = useRef(selectionRect);
	useEffect(() => {
		if (mainTrackMagnetEnabled && !mainTrackMagnetRef.current) {
			setElements(
				(prev) =>
					finalizeTimelineElements(prev, {
						mainTrackMagnetEnabled: true,
						attachments,
						autoAttach,
						fps,
						trackLockedMap,
					}),
				{ history: false },
			);
		}
		mainTrackMagnetRef.current = mainTrackMagnetEnabled;
	}, [
		mainTrackMagnetEnabled,
		setElements,
		attachments,
		autoAttach,
		fps,
		trackLockedMap,
	]);

	useEffect(() => {
		const handleKeyDown = (event: KeyboardEvent) => {
			if (event.key !== "Delete" && event.key !== "Backspace") return;
			if (event.repeat) return;
			if (
				event.target instanceof HTMLInputElement ||
				event.target instanceof HTMLTextAreaElement ||
				(event.target as HTMLElement | null)?.isContentEditable
			) {
				return;
			}
			if (selectedIds.length === 0) return;
			event.preventDefault();
			deleteSelectedElements();
		};

		window.addEventListener("keydown", handleKeyDown);
		return () => window.removeEventListener("keydown", handleKeyDown);
	}, [deleteSelectedElements, selectedIds.length]);

	useEffect(() => {
		const preventBrowserDrop = (event: DragEvent) => {
			if (!event.dataTransfer) return;
			if (event.dataTransfer.types?.includes("Files")) {
				event.preventDefault();
			}
		};

		const handleWindowDrop = (event: DragEvent) => {
			if (!event.dataTransfer) return;
			if (event.dataTransfer.files?.length) {
				event.preventDefault();
			}
		};

		window.addEventListener("dragover", preventBrowserDrop);
		window.addEventListener("drop", handleWindowDrop);
		return () => {
			window.removeEventListener("dragover", preventBrowserDrop);
			window.removeEventListener("drop", handleWindowDrop);
		};
	}, []);

	// 使用 callback ref 来监听容器宽度
	const rulerContainerRef = useCallback((node: HTMLDivElement | null) => {
		if (observerRef.current) {
			observerRef.current.disconnect();
			observerRef.current = null;
		}

		if (node) {
			const observer = new ResizeObserver((entries) => {
				for (const entry of entries) {
					setRulerWidth(entry.contentRect.width);
				}
			});
			observer.observe(node);
			observerRef.current = observer;
			setRulerWidth(node.clientWidth);
		}
	}, []);

	const ratio = getPixelsPerFrame(fps, timelineScale);

	const timelinePaddingLeft = 48;
	const zoomAnchorRef = useRef<{ clientX: number } | null>(null);
	const prevScaleRef = useRef(timelineScale);

	// 同步 scrollLeft 到全局拖拽 store
	const setTimelineScrollLeft = useDragStore(
		(state) => state.setTimelineScrollLeft,
	);
	const {
		startDrag,
		updateGhost,
		updateDropTarget,
		endDrag,
		setAutoScrollSpeedX,
		setAutoScrollSpeedY,
		stopAutoScroll,
	} = useDragStore();
	const isExternalDragActive = useDragStore(
		(state) => state.isDragging && state.dragSource === "external-file",
	);
	console.log(11111, isExternalDragActive);
	useEffect(() => {
		setTimelineScrollLeft(scrollLeft);
	}, [scrollLeft, setTimelineScrollLeft]);

	// 全局拖拽 store 的自动滚动
	const globalAutoScrollSpeedX = useDragStore(
		(state) => state.autoScrollSpeedX,
	);
	const globalAutoScrollSpeedY = useDragStore(
		(state) => state.autoScrollSpeedY,
	);

	// 更新元素的时间范围（start 和 end）
	const updateTimeRange = useCallback(
		(
			elementId: string,
			start: number,
			end: number,
			options?: { offsetDelta?: number },
		) => {
			setElements((prev) => {
				const updated = prev.map((el) => {
					if (el.id === elementId) {
						const timed = updateElementTime(el, start, end, fps);
						return applyOffsetDelta(timed, options?.offsetDelta);
					}
					return el;
				});
				return reconcileTransitions(updated, fps);
			});
		},
		[setElements, fps],
	);

	// hover 时设置预览时间（临时）
	const handleMouseMove = useCallback(
		(e: React.MouseEvent<HTMLDivElement>) => {
			const rect = e.currentTarget.getBoundingClientRect();
			lastHoverRef.current = {
				clientX: e.clientX,
				clientY: e.clientY,
				rectLeft: rect.left,
				rectRight: rect.right,
				rectTop: rect.top,
				rectBottom: rect.bottom,
			};
			if (isRulerDraggingRef.current) {
				setPreviewTime(null);
				return;
			}
			const x = e.clientX - rect.left;
			if (x <= leftColumnWidth) {
				setPreviewTime(null);
				return;
			}
			if (isPlaying || isDragging || isSelectingRef.current) return;
			if (!previewAxisEnabled) return;
			const time = clampFrame(
				(x - leftColumnWidth - timelinePaddingLeft + scrollLeft) / ratio,
			);
			startTransition(() => {
				setPreviewTime(time);
			});
		},
		[
			previewAxisEnabled,
			ratio,
			scrollLeft,
			leftColumnWidth,
			isPlaying,
			isDragging,
			setPreviewTime,
		],
	);

	const hasExternalFileDrag = useCallback(
		(dataTransfer: DataTransfer | null): boolean => {
			if (!dataTransfer) return false;
			if (dataTransfer.types?.includes("Files")) return true;
			if (dataTransfer.items) {
				return Array.from(dataTransfer.items).some(
					(item) => item.kind === "file",
				);
			}
			return false;
		},
		[],
	);

	const getExternalVideoFiles = useCallback(
		(dataTransfer: DataTransfer | null) => {
			if (!dataTransfer) return [];
			const files = Array.from(dataTransfer.files);
			return files.filter((file) => isVideoFile(file));
		},
		[],
	);

	const resolveExternalDropTarget = useCallback(
		(clientX: number, clientY: number) => {
			const dropTarget = findTimelineDropTargetFromScreenPosition(
				clientX,
				clientY,
				trackCount - 1,
			);
			const trackIndex = dropTarget.trackIndex ?? 0;
			const time =
				getTimelineDropTimeFromScreenX(
					clientX,
					trackIndex,
					ratio,
					scrollLeft,
				) ?? 0;
			const canDrop =
				dropTarget.type === "gap" || !(trackLockedMap.get(trackIndex) ?? false);
			return {
				zone: "timeline" as const,
				type: dropTarget.type,
				trackIndex,
				time,
				canDrop,
			};
		},
		[ratio, scrollLeft, trackCount, trackLockedMap],
	);

	const handleExternalDragEnter = useCallback(
		(event: React.DragEvent<HTMLDivElement>) => {
			if (!hasExternalFileDrag(event.dataTransfer)) return;
			event.preventDefault();
			if (externalDragActiveRef.current) return;
			externalDragActiveRef.current = true;
			externalDragOffsetRef.current = { x: 60, y: 40 };
			const dragData: MaterialDragData = {
				type: "video",
				uri: "",
				name: "视频文件",
			};
			startDrag("external-file", dragData, {
				screenX: event.clientX - externalDragOffsetRef.current.x,
				screenY: event.clientY - externalDragOffsetRef.current.y,
				width: 120,
				height: 80,
				label: dragData.name,
			});
		},
		[hasExternalFileDrag, startDrag],
	);

	const handleExternalDragOver = useCallback(
		(event: React.DragEvent<HTMLDivElement>) => {
			if (!hasExternalFileDrag(event.dataTransfer)) return;
			event.preventDefault();
			event.stopPropagation();

			if (!externalDragActiveRef.current) {
				externalDragActiveRef.current = true;
				externalDragOffsetRef.current = { x: 60, y: 40 };
				const dragData: MaterialDragData = {
					type: "video",
					uri: "",
					name: "视频文件",
				};
				startDrag("external-file", dragData, {
					screenX: event.clientX - externalDragOffsetRef.current.x,
					screenY: event.clientY - externalDragOffsetRef.current.y,
					width: 120,
					height: 80,
					label: dragData.name,
				});
			}

			updateGhost({
				screenX: event.clientX - externalDragOffsetRef.current.x,
				screenY: event.clientY - externalDragOffsetRef.current.y,
			});
			const dropTarget = resolveExternalDropTarget(
				event.clientX,
				event.clientY,
			);
			updateDropTarget(dropTarget);

			const scrollArea = scrollAreaRef.current;
			if (scrollArea) {
				const rect = scrollArea.getBoundingClientRect();
				const speedX = calculateAutoScrollSpeed(
					event.clientX,
					rect.left,
					rect.right,
				);
				setAutoScrollSpeedX(speedX);
			}

			const verticalScrollArea = verticalScrollRef.current;
			if (verticalScrollArea) {
				const rect = verticalScrollArea.getBoundingClientRect();
				const speedY = calculateAutoScrollSpeed(
					event.clientY,
					rect.top,
					rect.bottom,
				);
				setAutoScrollSpeedY(speedY);
			}
		},
		[
			hasExternalFileDrag,
			resolveExternalDropTarget,
			startDrag,
			setAutoScrollSpeedX,
			setAutoScrollSpeedY,
			updateDropTarget,
			updateGhost,
		],
	);

	const handleExternalDragLeave = useCallback(
		(event: React.DragEvent<HTMLDivElement>) => {
			if (!hasExternalFileDrag(event.dataTransfer)) return;
			event.preventDefault();
			stopAutoScroll();
			externalDragActiveRef.current = false;
			updateDropTarget(null);
			endDrag();
		},
		[hasExternalFileDrag, stopAutoScroll, updateDropTarget, endDrag],
	);

	const handleExternalDrop = useCallback(
		async (event: React.DragEvent<HTMLDivElement>) => {
			const files = getExternalVideoFiles(event.dataTransfer);
			if (files.length === 0) return;
			event.preventDefault();
			event.stopPropagation();

			const dropTarget =
				useDragStore.getState().dropTarget ??
				resolveExternalDropTarget(event.clientX, event.clientY);
			stopAutoScroll();
			externalDragActiveRef.current = false;
			updateDropTarget(null);
			endDrag();

			if (!dropTarget?.canDrop) {
				toast.error("当前轨道已锁定，无法放置");
				return;
			}

			const prepared = [];
			for (const file of files) {
				try {
					const { uri } = await writeVideoToOpfs(file);
					const metadata = await readVideoMetadata(file).catch(() =>
						getFallbackVideoMetadata(),
					);
					prepared.push({
						file,
						uri,
						metadata,
					});
				} catch (error) {
					console.warn("外部视频导入失败:", error);
					toast.error(`导入失败：${file.name}`);
				}
			}

			if (prepared.length === 0) return;

			setElements((prev) => {
				let nextElements = prev;
				let nextStart = clampFrame(dropTarget.time ?? 0);
				let targetTrackIndex = dropTarget.trackIndex ?? 0;
				let targetType: "track" | "gap" = dropTarget.type ?? "track";

				const postProcessOptions = {
					mainTrackMagnetEnabled,
					attachments,
					autoAttach,
					fps,
					trackLockedMap,
				};

				prepared.forEach((item, index) => {
					const durationFrames = Math.max(
						1,
						Math.round(item.metadata.duration * fps),
					);
					const startFrame = nextStart;
					const endFrame = startFrame + durationFrames;
					const insertIndex =
						targetType === "gap"
							? Math.max(1, targetTrackIndex)
							: targetTrackIndex;

					const newElement: TimelineElementType = {
						id: `external-video-${Date.now()}-${index}`,
						type: "VideoClip",
						component: "video-clip",
						name: item.file.name,
						props: {
							uri: item.uri,
						},
						transform: {
							centerX: 0,
							centerY: 0,
							width: item.metadata.width,
							height: item.metadata.height,
							rotation: 0,
						},
						timeline: buildTimelineMeta(
							{
								start: startFrame,
								end: endFrame,
								trackIndex: insertIndex,
								role: "clip",
							},
							fps,
						),
						render: {
							zIndex: 0,
							visible: true,
							opacity: 1,
						},
					};

					if (targetType === "gap") {
						const shifted = nextElements.map((el) => {
							const currentTrack = el.timeline.trackIndex ?? 0;
							if (currentTrack >= insertIndex) {
								return {
									...el,
									timeline: {
										...el.timeline,
										trackIndex: currentTrack + 1,
									},
								};
							}
							return el;
						});
						nextElements = finalizeTimelineElements(
							[...shifted, newElement],
							postProcessOptions,
						);
						targetType = "track";
					} else if (mainTrackMagnetEnabled && insertIndex === 0) {
						nextElements = insertElementIntoMainTrack(
							nextElements,
							newElement.id,
							startFrame,
							postProcessOptions,
							newElement,
						);
					} else {
						nextElements = finalizeTimelineElements(
							[...nextElements, newElement],
							postProcessOptions,
						);
					}

					const inserted = nextElements.find((el) => el.id === newElement.id);
					nextStart = inserted ? inserted.timeline.end : endFrame;
				});

				return nextElements;
			});
		},
		[
			getExternalVideoFiles,
			mainTrackMagnetEnabled,
			attachments,
			autoAttach,
			fps,
			trackLockedMap,
			resolveExternalDropTarget,
			stopAutoScroll,
			updateDropTarget,
			endDrag,
			setElements,
		],
	);

	// 点击时设置固定时间（可选清除选中状态）
	const handleClick = useCallback(
		(
			e: React.MouseEvent<HTMLDivElement>,
			options?: { keepSelection?: boolean },
		) => {
			if (
				selectionRect.visible &&
				selectionRect.x1 !== selectionRect.x2 &&
				selectionRect.y1 !== selectionRect.y2
			) {
				return;
			}
			const x = e.clientX - e.currentTarget.getBoundingClientRect().left;
			const time = clampFrame(
				(x - leftColumnWidth - timelinePaddingLeft + scrollLeft) / ratio,
			);
			setCurrentTime(time);
			setPreviewTime(null); // 清除预览时间
			if (!options?.keepSelection) {
				deselectAll(); // 清除选中状态
			}
		},
		[
			ratio,
			scrollLeft,
			leftColumnWidth,
			timelinePaddingLeft,
			setCurrentTime,
			setPreviewTime,
			deselectAll,
			selectionRect,
		],
	);

	const updateCurrentTimeFromClientX = useCallback(
		(clientX: number) => {
			const rect = timeStampsRef.current?.getBoundingClientRect();
			if (!rect) return;
			const x = clientX - rect.left;
			const time = clampFrame(
				(x - leftColumnWidth - timelinePaddingLeft + scrollLeft) / ratio,
			);
			setCurrentTime(time);
		},
		[leftColumnWidth, ratio, scrollLeft, setCurrentTime, timelinePaddingLeft],
	);

	// 时间尺点击只更新时间，不影响选中状态
	const handleRulerClick = useCallback(
		(e: React.MouseEvent<HTMLDivElement>) => {
			handleClick(e, { keepSelection: true });
		},
		[handleClick],
	);

	// 鼠标离开时清除预览时间，回到固定时间
	const handleMouseLeave = useCallback(() => {
		lastHoverRef.current = null;
		setPreviewTime(null);
	}, [setPreviewTime]);
	const bindRulerDrag = useDrag(
		({ first, last, tap, xy, cancel }) => {
			if (tap) return;
			if (first) {
				const rect = timeStampsRef.current?.getBoundingClientRect();
				if (!rect) return;
				const x = xy[0] - rect.left;
				if (x <= leftColumnWidth) {
					cancel?.();
					return;
				}
				isRulerDraggingRef.current = true;
				setPreviewTime(null);
			}
			updateCurrentTimeFromClientX(xy[0]);
			if (last) {
				isRulerDraggingRef.current = false;
			}
		},
		{
			filterTaps: true,
		},
	);

	useEffect(() => {
		if (selectionRect.visible) {
			setPreviewTime(null);
		}
	}, [selectionRect.visible, setPreviewTime]);

	useEffect(() => {
		if (wasDraggingRef.current && !isDragging && !isPlaying) {
			const lastHover = lastHoverRef.current;
			if (lastHover) {
				const isInside =
					lastHover.clientX >= lastHover.rectLeft &&
					lastHover.clientX <= lastHover.rectRight &&
					lastHover.clientY >= lastHover.rectTop &&
					lastHover.clientY <= lastHover.rectBottom;
				if (isInside && !isSelectingRef.current) {
					const x = lastHover.clientX - lastHover.rectLeft;
					if (!previewAxisEnabled || x <= leftColumnWidth) {
						setPreviewTime(null);
						wasDraggingRef.current = isDragging;
						return;
					}
					const time = clampFrame(
						(x - leftColumnWidth - timelinePaddingLeft + scrollLeft) / ratio,
					);
					setPreviewTime(time);
				}
			}
		}
		wasDraggingRef.current = isDragging;
	}, [
		isDragging,
		isPlaying,
		previewAxisEnabled,
		leftColumnWidth,
		ratio,
		scrollLeft,
		timelinePaddingLeft,
		setPreviewTime,
	]);

	const computeSelectionInRect = useCallback(
		(rect: { x1: number; y1: number; x2: number; y2: number }) => {
			const container = scrollAreaRef.current;
			if (!container) return [];
			const containerRect = container.getBoundingClientRect();
			const selBox = {
				x: Math.min(rect.x1, rect.x2),
				y: Math.min(rect.y1, rect.y2),
				width: Math.abs(rect.x2 - rect.x1),
				height: Math.abs(rect.y2 - rect.y1),
			};

			const elementsInDom = Array.from(
				container.querySelectorAll<HTMLElement>("[data-timeline-element]"),
			);
			const selected: string[] = [];
			for (const el of elementsInDom) {
				const elRect = el.getBoundingClientRect();
				const elBox = {
					x: elRect.left - containerRect.left,
					y: elRect.top - containerRect.top,
					width: elRect.width,
					height: elRect.height,
				};

				if (
					selBox.x < elBox.x + elBox.width &&
					selBox.x + selBox.width > elBox.x &&
					selBox.y < elBox.y + elBox.height &&
					selBox.y + selBox.height > elBox.y
				) {
					const elementId = el.dataset.elementId;
					if (elementId) {
						const trackIndex = trackAssignments.get(elementId) ?? 0;
						if (tracks[trackIndex]?.locked) {
							continue;
						}
						selected.push(elementId);
					}
				}
			}

			return selected;
		},
		[trackAssignments, tracks],
	);

	const applyMarqueeSelection = useCallback(
		(nextRect: { x1: number; y1: number; x2: number; y2: number }) => {
			const selected = computeSelectionInRect(nextRect);
			if (selectionAdditiveRef.current) {
				const merged = Array.from(
					new Set([...initialSelectedIdsRef.current, ...selected]),
				);
				const primary =
					selected[selected.length - 1] ??
					initialSelectedIdsRef.current[0] ??
					null;
				setSelection(merged, primary);
			} else {
				setSelection(selected, selected[0] ?? null);
			}
		},
		[computeSelectionInRect, setSelection],
	);

	const handleSelectionMouseDown = useCallback(
		(e: React.MouseEvent<HTMLDivElement>) => {
			if (e.button !== 0) return;
			const target = e.target as HTMLElement;
			if (target.closest("[data-timeline-element]")) {
				return;
			}

			const container = scrollAreaRef.current;
			if (!container) return;
			const rect = container.getBoundingClientRect();

			isSelectingRef.current = true;
			selectionActivatedRef.current = false;
			selectionStartRef.current = null;
			selectionAdditiveRef.current = e.shiftKey || e.ctrlKey || e.metaKey;
			initialSelectedIdsRef.current = selectedIds;

			const x = e.clientX - rect.left;
			const y = e.clientY - rect.top;
			selectionStartRef.current = { x, y };
			const nextRect = {
				visible: false,
				x1: x,
				y1: y,
				x2: x,
				y2: y,
			};
			selectionRectRef.current = nextRect;
			setSelectionRect(nextRect);
		},
		[selectedIds],
	);

	const handleSelectionMouseMove = useCallback(
		(e: React.MouseEvent<HTMLDivElement>) => {
			if (!isSelectingRef.current) return;
			const container = scrollAreaRef.current;
			if (!container) return;
			const rect = container.getBoundingClientRect();
			const x = e.clientX - rect.left;
			const y = e.clientY - rect.top;
			const start = selectionStartRef.current ?? { x, y };
			const deltaX = x - start.x;
			const deltaY = y - start.y;
			if (
				!selectionActivatedRef.current &&
				Math.abs(deltaX) < 2 &&
				Math.abs(deltaY) < 2
			) {
				return;
			}
			if (!selectionActivatedRef.current) {
				selectionActivatedRef.current = true;
				setPreviewTime(null); // 进入框选后暂停预览，避免画面闪烁
			}
			const nextRect = {
				visible: true,
				x1: start.x,
				y1: start.y,
				x2: x,
				y2: y,
			};
			selectionRectRef.current = nextRect;
			setSelectionRect(nextRect);
			applyMarqueeSelection(nextRect);
		},
		[applyMarqueeSelection, setPreviewTime],
	);

	const handleSelectionMouseUp = useCallback(() => {
		if (!isSelectingRef.current) return;
		isSelectingRef.current = false;
		const wasActivated = selectionActivatedRef.current;
		selectionActivatedRef.current = false;
		selectionStartRef.current = null;

		if (!wasActivated) {
			setSelectionRect((prev) =>
				prev.visible ? { ...prev, visible: false } : prev,
			);
			return;
		}

		setTimeout(() => {
			setSelectionRect((prev) => ({ ...prev, visible: false }));
		}, 0);
		applyMarqueeSelection(selectionRectRef.current);
	}, [applyMarqueeSelection]);

	useEffect(() => {
		const handleWindowMouseUp = () => {
			handleSelectionMouseUp();
		};
		window.addEventListener("mouseup", handleWindowMouseUp);
		return () => {
			window.removeEventListener("mouseup", handleWindowMouseUp);
		};
	}, [handleSelectionMouseUp]);

	// 同步 scrollLeft 到 ref
	useEffect(() => {
		scrollLeftRef.current = scrollLeft;
	}, [scrollLeft]);

	// 使用原生事件监听器来正确处理滚动，防止触发窗口滚动
	useEffect(() => {
		const scrollArea = scrollAreaRef.current;
		if (!scrollArea) return;

		const handleWheel = (e: WheelEvent) => {
			if (e.ctrlKey) {
				e.preventDefault();
				e.stopPropagation();

				const currentScale = useTimelineStore.getState().timelineScale;
				const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
				const nextScale = Math.min(
					10,
					Math.max(0.01, currentScale * zoomFactor),
				);

				zoomAnchorRef.current = { clientX: e.clientX };
				useTimelineStore.getState().setTimelineScale(nextScale);
				return;
			}

			// 只在有水平滚动时才处理，垂直滚动不处理
			if (Math.abs(e.deltaX) > 0) {
				// 阻止水平滚动事件的默认行为，防止触发窗口滚动
				e.preventDefault();
				e.stopPropagation();

				// 修复方向：向右滚动（deltaX > 0）应该增加 scrollLeft
				const currentScrollLeft = useTimelineStore.getState().scrollLeft;
				const newScrollLeft = Math.max(0, currentScrollLeft + e.deltaX);
				setScrollLeft(newScrollLeft);
			}
			// 如果是纯垂直滚动（只有 deltaY），不阻止默认行为，让页面正常滚动
		};

		// 阻止触摸手势（防止后退）
		const handleTouchStart = (e: TouchEvent) => {
			if (e.touches.length === 1) {
				const touch = e.touches[0];
				const rect = scrollArea.getBoundingClientRect();
				// 如果触摸点在容器内，阻止默认行为（防止后退手势）
				if (
					touch.clientX >= rect.left &&
					touch.clientX <= rect.right &&
					touch.clientY >= rect.top &&
					touch.clientY <= rect.bottom
				) {
					e.preventDefault();
					e.stopPropagation();
					touchStartXRef.current = touch.clientX;
				}
			}
		};

		const handleTouchMove = (e: TouchEvent) => {
			if (e.touches.length === 1) {
				e.preventDefault();
				e.stopPropagation();
				const touch = e.touches[0];
				const deltaX = touchStartXRef.current - touch.clientX;
				setScrollLeft(Math.max(0, scrollLeftRef.current + deltaX));
			}
		};

		// 使用 { passive: false } 来确保可以调用 preventDefault
		scrollArea.addEventListener("wheel", handleWheel, { passive: false });
		scrollArea.addEventListener("touchstart", handleTouchStart, {
			passive: false,
		});
		scrollArea.addEventListener("touchmove", handleTouchMove, {
			passive: false,
		});

		return () => {
			scrollArea.removeEventListener("wheel", handleWheel);
			scrollArea.removeEventListener("touchstart", handleTouchStart);
			scrollArea.removeEventListener("touchmove", handleTouchMove);
		};
	}, []);

	useEffect(() => {
		const scrollArea = scrollAreaRef.current;
		if (!scrollArea) {
			prevScaleRef.current = timelineScale;
			return;
		}

		const prevScale = prevScaleRef.current;
		if (prevScale === timelineScale) return;

		const rect = scrollArea.getBoundingClientRect();
		const anchorX = (() => {
			const anchor = zoomAnchorRef.current;
			const rawX = anchor
				? anchor.clientX - rect.left
				: leftColumnWidth + (scrollArea.clientWidth - leftColumnWidth) / 2;
			return Math.max(0, Math.min(scrollArea.clientWidth, rawX));
		})();

		const prevRatio = getPixelsPerFrame(fps, prevScale);
		const nextRatio = getPixelsPerFrame(fps, timelineScale);
		if (!Number.isFinite(prevRatio) || !Number.isFinite(nextRatio)) {
			prevScaleRef.current = timelineScale;
			zoomAnchorRef.current = null;
			return;
		}

		const currentScrollLeft = scrollLeftRef.current;
		if (currentScrollLeft <= 0.5) {
			prevScaleRef.current = timelineScale;
			zoomAnchorRef.current = null;
			return;
		}
		const offsetX = anchorX - leftColumnWidth - timelinePaddingLeft;
		const timeAtAnchor = Math.max(0, (offsetX + currentScrollLeft) / prevRatio);
		const nextScrollLeft = Math.max(0, timeAtAnchor * nextRatio - offsetX);

		if (Number.isFinite(nextScrollLeft)) {
			setScrollLeft(nextScrollLeft);
		}

		prevScaleRef.current = timelineScale;
		zoomAnchorRef.current = null;
	}, [fps, leftColumnWidth, setScrollLeft, timelineScale, timelinePaddingLeft]);

	// 自动滚动效果（拖拽到边缘时触发）
	useEffect(() => {
		if (autoScrollSpeed === 0) return;

		let animationFrameId: number;

		const animate = () => {
			const currentScrollLeft = useTimelineStore.getState().scrollLeft;
			const newScrollLeft = Math.max(0, currentScrollLeft + autoScrollSpeed);
			setScrollLeft(newScrollLeft);
			animationFrameId = requestAnimationFrame(animate);
		};

		animationFrameId = requestAnimationFrame(animate);

		return () => {
			cancelAnimationFrame(animationFrameId);
		};
	}, [autoScrollSpeed, setScrollLeft]);

	// 垂直自动滚动效果（拖拽到上下边缘时触发）
	useEffect(() => {
		if (autoScrollSpeedY === 0) return;

		const scrollContainer = verticalScrollRef.current;
		if (!scrollContainer) return;

		let animationFrameId: number;

		const animate = () => {
			const currentScrollTop = scrollContainer.scrollTop;
			const maxScrollTop =
				scrollContainer.scrollHeight - scrollContainer.clientHeight;
			const newScrollTop = Math.max(
				0,
				Math.min(maxScrollTop, currentScrollTop + autoScrollSpeedY),
			);
			scrollContainer.scrollTop = newScrollTop;
			animationFrameId = requestAnimationFrame(animate);
		};

		animationFrameId = requestAnimationFrame(animate);

		return () => {
			cancelAnimationFrame(animationFrameId);
		};
	}, [autoScrollSpeedY]);

	// 素材库拖拽时的水平自动滚动
	useEffect(() => {
		if (globalAutoScrollSpeedX === 0) return;

		let animationFrameId: number;

		const animate = () => {
			const currentScrollLeft = useTimelineStore.getState().scrollLeft;
			const newScrollLeft = Math.max(
				0,
				currentScrollLeft + globalAutoScrollSpeedX,
			);
			setScrollLeft(newScrollLeft);
			animationFrameId = requestAnimationFrame(animate);
		};

		animationFrameId = requestAnimationFrame(animate);

		return () => {
			cancelAnimationFrame(animationFrameId);
		};
	}, [globalAutoScrollSpeedX, setScrollLeft]);

	// 素材库拖拽时的垂直自动滚动
	useEffect(() => {
		if (globalAutoScrollSpeedY === 0) return;

		const scrollContainer = verticalScrollRef.current;
		if (!scrollContainer) return;

		let animationFrameId: number;

		const animate = () => {
			const currentScrollTop = scrollContainer.scrollTop;
			const maxScrollTop =
				scrollContainer.scrollHeight - scrollContainer.clientHeight;
			const newScrollTop = Math.max(
				0,
				Math.min(maxScrollTop, currentScrollTop + globalAutoScrollSpeedY),
			);
			scrollContainer.scrollTop = newScrollTop;
			animationFrameId = requestAnimationFrame(animate);
		};

		animationFrameId = requestAnimationFrame(animate);

		return () => {
			cancelAnimationFrame(animationFrameId);
		};
	}, [globalAutoScrollSpeedY]);

	const trackLayout = useMemo(() => {
		return buildTrackLayout(tracks);
	}, [tracks]);

	const trackLayoutByIndex = useMemo(() => {
		const map = new Map<number, (typeof trackLayout)[number]>();
		for (const item of trackLayout) {
			map.set(item.index, item);
		}
		return map;
	}, [trackLayout]);

	const otherTrackLayout = useMemo(() => {
		return trackLayout.filter((item) => item.index > 0);
	}, [trackLayout]);

	const otherTrackHeights = useMemo(() => {
		return otherTrackLayout.map((item) => item.height);
	}, [otherTrackLayout]);

	const otherTracksHeight = useMemo(() => {
		return otherTrackLayout.reduce((sum, item) => sum + item.height, 0);
	}, [otherTrackLayout]);
	const mainTrackHeight = useMemo(() => {
		return trackLayoutByIndex.get(0)?.height ?? getTrackHeightByRole("clip");
	}, [trackLayoutByIndex]);
	const selectionBox = useMemo(() => {
		if (!selectionRect.visible) return null;
		const x = Math.min(selectionRect.x1, selectionRect.x2);
		const y = Math.min(selectionRect.y1, selectionRect.y2);
		const width = Math.abs(selectionRect.x2 - selectionRect.x1);
		const height = Math.abs(selectionRect.y2 - selectionRect.y1);
		return { x, y, width, height };
	}, [selectionRect]);

	const timeStamps = useMemo(() => {
		return (
			<div
				key="time-stamps"
				className="sticky top-0 left-0 z-60"
				ref={timeStampsRef}
				onMouseMove={handleMouseMove}
				onClick={handleRulerClick}
				onMouseLeave={handleMouseLeave}
				{...bindRulerDrag()}
			>
				{isExternalDragActive && (
					<div className="absolute inset-0 z-90 pointer-events-none">
						{/* 外部拖拽高亮提示 */}
						<div className="absolute inset-3 rounded-2xl border border-blue-500/60 bg-blue-500/10 shadow-[0_0_30px_rgba(59,130,246,0.25)]" />
						<div className="absolute top-6 left-1/2 -translate-x-1/2 rounded-full bg-blue-500/15 text-blue-200 text-xs px-3 py-1 border border-blue-500/30 backdrop-blur">
							松手导入视频到时间线
						</div>
					</div>
				)}
				<div className="flex bg-neutral-800/10 border border-white/10 rounded-full mx-4 backdrop-blur-2xl overflow-hidden">
					<div
						className="border-r border-white/10"
						style={{ width: leftColumnWidth - 16 - 1 }}
					>
						<div className="h-full text-[11px] flex items-center justify-end pr-6 font-mono text-neutral-300">
							{formatTimecode(currentTime, fps)}
						</div>
					</div>
					<div
						ref={rulerContainerRef}
						className="overflow-hidden bg-neutral-800/30 flex-1"
					>
						<TimelineRuler
							scrollLeft={scrollLeft}
							ratio={ratio}
							width={rulerWidth}
							paddingLeft={timelinePaddingLeft}
							fps={fps}
						/>
					</div>
				</div>
			</div>
		);
	}, [
		isExternalDragActive,
		handleMouseMove,
		handleClick,
		leftColumnWidth,
		currentTime,
		fps,
		scrollLeft,
		ratio,
		rulerWidth,
		timelinePaddingLeft,
	]);

	// 分离主轨道元素和其他轨道元素
	const { mainTrackElements, otherTrackElements } = useMemo(() => {
		const main: typeof elements = [];
		const other: typeof elements = [];
		for (const element of elements) {
			const trackIndex = trackAssignments.get(element.id) ?? 0;
			if (trackIndex === 0) {
				main.push(element);
			} else {
				other.push(element);
			}
		}
		return { mainTrackElements: main, otherTrackElements: other };
	}, [elements, trackAssignments, tracks]);

	// 其他轨道数量（不包括主轨道）
	const otherTrackCount = Math.max(trackCount - 1, 0);
	const mainTrackVisible = !(tracks[0]?.hidden ?? false);
	const mainTrackLocked = tracks[0]?.locked ?? false;

	// 其他轨道的时间线项目
	const otherTimelineItems = useMemo(() => {
		if (otherTrackCount === 0) return null;

		const containerHeight = otherTracksHeight;

		return (
			<div
				className="relative"
				style={{
					transform: `translateX(-${scrollLeft}px)`,
					height: containerHeight,
				}}
			>
				{otherTrackElements.map((element) => {
					const trackIndex = trackAssignments.get(element.id) ?? 0;
					const layoutItem = trackLayoutByIndex.get(trackIndex);
					const y = (layoutItem?.y ?? 0) + TRACK_CONTENT_GAP / 2;
					const elementTrackHeight =
						layoutItem?.height ?? getTrackHeightByRole("overlay");
					const trackVisible = !(tracks[trackIndex]?.hidden ?? false);
					const trackLocked = tracks[trackIndex]?.locked ?? false;
					return (
						<TimelineElement
							key={element.id}
							element={element}
							trackIndex={trackIndex}
							trackY={y}
							ratio={ratio}
							trackHeight={elementTrackHeight}
							trackCount={trackCount}
							trackVisible={trackVisible}
							trackLocked={trackLocked}
							updateTimeRange={updateTimeRange}
						/>
					);
				})}
			</div>
		);
	}, [
		otherTrackElements,
		scrollLeft,
		ratio,
		updateTimeRange,
		trackAssignments,
		trackCount,
		otherTrackCount,
		otherTracksHeight,
		trackLayoutByIndex,
		tracks,
	]);

	// 锁定轨道的斜线纹理遮罩
	const otherTrackLockedOverlays = useMemo(() => {
		if (otherTrackCount === 0) return null;
		return otherTrackLayout.map((item) => {
			const trackLocked = tracks[item.index]?.locked ?? false;
			if (!trackLocked) return null;
			return (
				<div
					key={`track-locked-${tracks[item.index]?.id ?? item.index}`}
					className="absolute right-0 z-10 bg-black/10"
					style={{
						top: item.y,
						left: -timelinePaddingLeft,
						height: item.height,
						...LOCKED_TRACK_OVERLAY_STYLE,
					}}
				/>
			);
		});
	}, [otherTrackCount, otherTrackLayout, tracks, timelinePaddingLeft]);

	const mainTrackLockedOverlay = useMemo(() => {
		if (!mainTrackLocked) return null;
		return (
			<div
				className="absolute right-0 top-0 z-10 bg-black/10"
				style={{
					left: -timelinePaddingLeft,
					height: mainTrackHeight,
					...LOCKED_TRACK_OVERLAY_STYLE,
				}}
			/>
		);
	}, [mainTrackHeight, mainTrackLocked, timelinePaddingLeft]);

	// 主轨道的时间线项目
	const mainTimelineItems = useMemo(() => {
		// 主轨道在整体布局中的 Y 坐标（用于拖拽计算）
		const mainTrackYInGlobalLayout =
			trackLayoutByIndex.get(0)?.y ?? otherTracksHeight;

		return (
			<div
				className="relative"
				style={{
					transform: `translateX(-${scrollLeft}px) translateY(${TRACK_CONTENT_GAP / 2}px)`,
					height: mainTrackHeight,
				}}
			>
				{mainTrackElements.map((element) => {
					return (
						<TimelineElement
							key={element.id}
							element={element}
							trackIndex={0}
							trackY={mainTrackYInGlobalLayout}
							ratio={ratio}
							trackHeight={mainTrackHeight}
							trackCount={trackCount}
							trackVisible={mainTrackVisible}
							trackLocked={mainTrackLocked}
							updateTimeRange={updateTimeRange}
						/>
					);
				})}
			</div>
		);
	}, [
		mainTrackElements,
		scrollLeft,
		ratio,
		updateTimeRange,
		trackCount,
		trackLayoutByIndex,
		otherTracksHeight,
		mainTrackHeight,
		mainTrackLocked,
		mainTrackVisible,
	]);

	// 其他轨道标签（不包括主轨道）
	const otherTrackLabels = useMemo(() => {
		if (otherTrackCount === 0) return null;
		return otherTrackLayout.map((item) => {
			const track = tracks[item.index];
			if (!track) return null;
			const trackVisible = !(track.hidden ?? false);
			return (
				<TimelineTrackSidebarItem
					key={track.id}
					track={track}
					label={`轨道 ${item.role}`}
					height={item.height}
					className={cn("text-neutral-400", {
						"bg-black/60": !trackVisible,
					})}
					labelClassName={trackVisible ? "" : "text-neutral-600"}
					onToggleVisible={() => toggleTrackHidden(track.id)}
					onToggleLocked={() => toggleTrackLocked(track.id)}
					onToggleMuted={() => toggleTrackMuted(track.id)}
					onToggleSolo={() => toggleTrackSolo(track.id)}
				/>
			);
		});
	}, [
		otherTrackCount,
		otherTrackLayout,
		tracks,
		toggleTrackHidden,
		toggleTrackLocked,
		toggleTrackMuted,
		toggleTrackSolo,
	]);

	const otherTrackBackgrounds = useMemo(() => {
		if (otherTrackCount === 0) return null;
		return otherTrackLayout.map((item) => {
			const trackHidden = tracks[item.index]?.hidden ?? false;
			if (!trackHidden) return null;
			return (
				<div
					key={`track-bg-${tracks[item.index]?.id ?? item.index}`}
					className={cn("absolute left-0 right-0 pointer-events-none", {
						"bg-black/60": trackHidden,
					})}
					style={{
						top: item.y,
						left: -timelinePaddingLeft,
						height: item.height,
					}}
				/>
			);
		});
	}, [otherTrackCount, otherTrackLayout, tracks, timelinePaddingLeft]);

	// 主轨道标签
	const mainTrackLabel = useMemo(() => {
		const mainTrack = tracks[0];
		if (!mainTrack) return null;
		return (
			<TimelineTrackSidebarItem
				track={mainTrack}
				label="主轨道"
				height={mainTrackHeight}
				className="text-blue-400"
				labelClassName={mainTrackVisible ? "text-blue-400" : "text-neutral-600"}
				onToggleVisible={() => toggleTrackHidden(mainTrack.id)}
				onToggleLocked={() => toggleTrackLocked(mainTrack.id)}
				onToggleMuted={() => toggleTrackMuted(mainTrack.id)}
				onToggleSolo={() => toggleTrackSolo(mainTrack.id)}
			/>
		);
	}, [
		mainTrackHeight,
		mainTrackVisible,
		toggleTrackHidden,
		toggleTrackLocked,
		toggleTrackMuted,
		toggleTrackSolo,
		tracks,
	]);

	// 吸附指示线
	const snapIndicator = useMemo(() => {
		if (!activeSnapPoint || otherTrackCount === 0) return null;
		const left = activeSnapPoint.time * ratio - scrollLeft;
		return (
			<div
				className="absolute top-12 bottom-0 w-px bg-green-500 pointer-events-none"
				style={{ left: left + timelinePaddingLeft }}
			/>
		);
	}, [
		activeSnapPoint,
		ratio,
		scrollLeft,
		otherTrackCount,
		timelinePaddingLeft,
	]);

	return (
		<div
			className="relative bg-neutral-800 h-full flex flex-col min-h-0 w-full overflow-hidden"
			onMouseLeave={handleMouseLeave}
		>
			<div className="pointer-events-none absolute top-0 left-0 w-full h-19 z-50 bg-linear-to-b from-neutral-800 via-neutral-800 via-70% to-transparent"></div>
			<ProgressiveBlur
				position="top"
				className="absolute top-0 w-full h-20 z-60 "
				blurLevels={[0.5, 4, 16, 16, 16, 16, 16, 16]}
			/>
			<TimelineToolbar className="h-12 z-60" />
			{timeStamps}
			<div
				ref={scrollAreaRef}
				data-timeline-scroll-area
				className="relative w-full flex-1 min-h-0 flex flex-col -mt-18 overflow-hidden"
				onMouseMove={(e) => {
					handleMouseMove(e);
					handleSelectionMouseMove(e);
				}}
				onMouseDown={handleSelectionMouseDown}
				onMouseUp={handleSelectionMouseUp}
				onMouseLeave={handleMouseLeave}
				onClick={handleClick}
				onDragEnter={handleExternalDragEnter}
				onDragOver={handleExternalDragOver}
				onDragLeave={handleExternalDragLeave}
				onDrop={handleExternalDrop}
			>
				{selectionBox && selectionBox.width > 0 && selectionBox.height > 0 && (
					<div
						className="absolute border z-70 border-blue-500/80 bg-blue-500/10 pointer-events-none"
						style={{
							left: selectionBox.x,
							top: selectionBox.y,
							width: selectionBox.width,
							height: selectionBox.height,
						}}
					/>
				)}
				<div
					className="h-full w-full absolute top-0 left-0 pointer-events-none z-60"
					style={{ marginLeft: leftColumnWidth }}
				>
					<TimeIndicatorCanvas
						className="top-12 z-50"
						leftOffset={timelinePaddingLeft}
						ratio={ratio}
						scrollLeft={scrollLeft}
					/>
				</div>
				<div
					className="h-full w-full absolute top-0 left-0 pointer-events-none z-50"
					style={{ marginLeft: leftColumnWidth }}
				>
					{snapIndicator}
				</div>

				{/* 轨道区域（可滚动） */}
				<div
					ref={verticalScrollRef}
					data-vertical-scroll-area
					className="w-full flex-1 min-h-0 overflow-y-auto"
				>
					<div className="relative flex flex-col min-h-full">
						<div
							className="z-10 absolute left-0 top-0 h-full pointer-events-none bg-neutral-800/80 backdrop-blur-3xl backdrop-saturate-150 border-r border-white/10"
							style={{ width: leftColumnWidth }}
						/>
						{/* 其他轨道区域 */}
						<div className="flex flex-1 mt-18">
							{/* 左侧列，其他轨道标签 */}
							<div
								className="text-white z-10 pr-px flex flex-col"
								style={{ width: leftColumnWidth }}
							>
								<div className="flex-1 flex flex-col justify-end">
									<div className="mt-1.5">{otherTrackLabels}</div>
								</div>
							</div>
							{/* 右侧其他轨道时间线内容 */}
							<div
								ref={containerRef}
								data-track-drop-zone="other"
								data-track-count={otherTrackCount}
								data-track-heights={otherTrackHeights.join(",")}
								className="relative flex-1 overflow-x-hidden pt-1.5 flex flex-col justify-end"
								style={{
									paddingLeft: leftColumnWidth,
									marginLeft: -leftColumnWidth,
								}}
							>
								<div style={{ paddingLeft: timelinePaddingLeft }}>
									<div
										className="relative"
										data-track-content-area="other"
										data-content-height={otherTracksHeight}
									>
										{otherTrackBackgrounds}
										{otherTrackLockedOverlays}
										{otherTimelineItems}
									</div>
								</div>
							</div>
						</div>
						{/* 主轨道区域（sticky 底部） */}
						<div className="z-10 flex items-start border-t border-b border-white/10 sticky bottom-0">
							{/* 左侧主轨道标签 */}
							<div
								className={`text-white z-10 pr-px flex flex-col ${
									mainTrackVisible ? "bg-neutral-900/90" : "bg-black/80"
								} backdrop-blur-2xl border-r border-white/10`}
								style={{ width: leftColumnWidth }}
							>
								{mainTrackLabel}
							</div>
							{/* 右侧主轨道时间线内容 */}
							<div
								data-track-drop-zone="main"
								data-track-index="0"
								className="relative flex-1 overflow-x-hidden backdrop-blur-2xl"
								onMouseMove={handleMouseMove}
								onMouseLeave={handleMouseLeave}
								onClick={handleClick}
								style={{
									paddingLeft: leftColumnWidth,
									marginLeft: -leftColumnWidth,
								}}
							>
								<div style={{ paddingLeft: timelinePaddingLeft }}>
									<div className="relative" data-track-content-area="main">
										{mainTrackLockedOverlay}
										{mainTimelineItems}
									</div>
								</div>
							</div>
						</div>
						{/* 音频轨道区域 */}
						<div className="z-10 flex-1">
							{/* 左侧音频轨道标签 */}
							<div
								className="h-full text-white pr-4 flex flex-col z-10"
								style={{ width: leftColumnWidth }}
							>
								{/* <div className="h-12 flex items-center justify-end pr-3 text-xs font-medium text-neutral-400">
									音频轨道
								</div> */}
							</div>
							{/* TODO: 右侧音频轨道时间线内容 */}
						</div>
					</div>
				</div>
				{/* 拖拽 Ghost 层 */}
				<TimelineDragOverlay
					activeDropTarget={activeDropTarget}
					dragGhosts={dragGhosts}
					ratio={ratio}
					scrollLeft={scrollLeft}
					otherTrackCount={otherTrackCount}
					otherTrackHeights={otherTrackHeights}
					mainTrackHeight={mainTrackHeight}
					timelinePaddingLeft={timelinePaddingLeft}
				/>
			</div>
		</div>
	);
};

export default TimelineEditor;
