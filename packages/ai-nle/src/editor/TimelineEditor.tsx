import React, {
	startTransition,
	useCallback,
	useEffect,
	useMemo,
	useRef,
	useState,
} from "react";
import { ProgressiveBlur } from "@/components/ui/progressive-blur";
import TimeIndicatorCanvas from "@/editor/components/TimeIndicatorCanvas";
import { clampFrame, framesToTimecode } from "@/utils/timecode";
import TimelineDragOverlay from "./components/TimelineDragOverlay";
import TimelineElement from "./components/TimelineElement";
import TimelineRuler from "./components/TimelineRuler";
import TimelineToolbar from "./components/TimelineToolbar";
import {
	useAttachments,
	useAutoScroll,
	useCurrentTime,
	useDragging,
	useElements,
	useFps,
	useMainTrackMagnet,
	useMultiSelect,
	usePlaybackControl,
	usePreviewTime,
	useSnap,
	useTimelineScale,
	useTimelineStore,
	useTrackAssignments,
} from "./contexts/TimelineContext";
import { useDragStore } from "./drag";
import { finalizeTimelineElements } from "./utils/mainTrackMagnet";
import { getPixelsPerFrame } from "./utils/timelineScale";
import { updateElementTime } from "./utils/timelineTime";
import {
	assignTracks,
	buildTrackLayout,
	getTrackHeightByRole,
	normalizeTrackAssignments,
} from "./utils/trackAssignment";

const formatTimecode = (frames: number, fps: number) => {
	return framesToTimecode(frames, fps);
};

const TimelineEditor = () => {
	const setCurrentTime = useTimelineStore((state) => state.setCurrentTime);
	const scrollLeft = useTimelineStore((state) => state.scrollLeft);
	const setScrollLeft = useTimelineStore((state) => state.setScrollLeft);
	const { setPreviewTime } = usePreviewTime();
	const { isPlaying } = usePlaybackControl();
	const { currentTime } = useCurrentTime();
	const { fps } = useFps();
	const { timelineScale } = useTimelineScale();
	const { elements, setElements } = useElements();
	const { selectedIds, deselectAll, setSelection } = useMultiSelect();
	const { activeSnapPoint } = useSnap();
	const { trackAssignments, trackCount } = useTrackAssignments();
	const { activeDropTarget, dragGhosts, isDragging } = useDragging();
	const { autoScrollSpeed, autoScrollSpeedY } = useAutoScroll();
	const { attachments, autoAttach } = useAttachments();
	const { mainTrackMagnetEnabled } = useMainTrackMagnet();
	const deleteSelectedElements = useCallback(() => {
		if (selectedIds.length === 0) return;
		setElements((prev) => {
			const nextElements = prev.filter((el) => !selectedIds.includes(el.id));
			if (nextElements.length === prev.length) return prev;
			if (nextElements.length === 0) return nextElements;
			const normalized = normalizeTrackAssignments(assignTracks(nextElements));
			let didChange = false;
			const withTracks = nextElements.map((el) => {
				const nextTrack = normalized.get(el.id);
				const currentTrack = el.timeline.trackIndex ?? 0;
				if (nextTrack === undefined || nextTrack === currentTrack) return el;
				didChange = true;
				return { ...el, timeline: { ...el.timeline, trackIndex: nextTrack } };
			});
			return didChange ? withTracks : nextElements;
		});
		deselectAll();
	}, [selectedIds, setElements, deselectAll]);

	const mainTrackMagnetRef = useRef(mainTrackMagnetEnabled);

	// 滚动位置 refs
	const containerRef = useRef<HTMLDivElement>(null);
	const scrollAreaRef = useRef<HTMLDivElement>(null);
	const verticalScrollRef = useRef<HTMLDivElement>(null);
	const scrollLeftRef = useRef(0);
	const touchStartXRef = useRef(0);
	const isSelectingRef = useRef(false);
	const selectionAdditiveRef = useRef(false);
	const initialSelectedIdsRef = useRef<string[]>([]);
	const lastHoverRef = useRef<{
		clientX: number;
		clientY: number;
		rectLeft: number;
		rectRight: number;
		rectTop: number;
		rectBottom: number;
	} | null>(null);
	const wasDraggingRef = useRef(false);

	// 左侧列宽度状态
	const [leftColumnWidth] = useState(200); // 默认 44 * 4 = 176px (w-44)

	// 时间刻度尺宽度
	const [rulerWidth, setRulerWidth] = useState(800);
	const observerRef = useRef<ResizeObserver | null>(null);
	const [selectionRect, setSelectionRect] = useState({
		visible: false,
		x1: 0,
		y1: 0,
		x2: 0,
		y2: 0,
	});
	const selectionRectRef = useRef(selectionRect);

	useEffect(() => {
		if (mainTrackMagnetEnabled && !mainTrackMagnetRef.current) {
			setElements((prev) =>
				finalizeTimelineElements(prev, {
					mainTrackMagnetEnabled: true,
					attachments,
					autoAttach,
					fps,
				}),
			);
		}
		mainTrackMagnetRef.current = mainTrackMagnetEnabled;
	}, [mainTrackMagnetEnabled, setElements, attachments, autoAttach, fps]);

	useEffect(() => {
		const handleKeyDown = (event: KeyboardEvent) => {
			if (event.key !== "Delete" && event.key !== "Backspace") return;
			if (event.repeat) return;
			if (
				event.target instanceof HTMLInputElement ||
				event.target instanceof HTMLTextAreaElement ||
				(event.target as HTMLElement | null)?.isContentEditable
			) {
				return;
			}
			if (selectedIds.length === 0) return;
			event.preventDefault();
			deleteSelectedElements();
		};

		window.addEventListener("keydown", handleKeyDown);
		return () => window.removeEventListener("keydown", handleKeyDown);
	}, [deleteSelectedElements, selectedIds.length]);

	// 使用 callback ref 来监听容器宽度
	const rulerContainerRef = useCallback((node: HTMLDivElement | null) => {
		if (observerRef.current) {
			observerRef.current.disconnect();
			observerRef.current = null;
		}

		if (node) {
			const observer = new ResizeObserver((entries) => {
				for (const entry of entries) {
					setRulerWidth(entry.contentRect.width);
				}
			});
			observer.observe(node);
			observerRef.current = observer;
			setRulerWidth(node.clientWidth);
		}
	}, []);

	const ratio = getPixelsPerFrame(fps, timelineScale);

	const timelinePaddingLeft = 48;

	// 同步 scrollLeft 到全局拖拽 store
	const setTimelineScrollLeft = useDragStore(
		(state) => state.setTimelineScrollLeft,
	);
	useEffect(() => {
		setTimelineScrollLeft(scrollLeft);
	}, [scrollLeft, setTimelineScrollLeft]);

	// 全局拖拽 store 的自动滚动
	const globalAutoScrollSpeedX = useDragStore(
		(state) => state.autoScrollSpeedX,
	);
	const globalAutoScrollSpeedY = useDragStore(
		(state) => state.autoScrollSpeedY,
	);

	// 更新元素的时间范围（start 和 end）
	const updateTimeRange = useCallback(
		(elementId: string, start: number, end: number) => {
			setElements((prev) =>
				prev.map((el) => {
					if (el.id === elementId) {
						return updateElementTime(el, start, end, fps);
					}
					return el;
				}),
			);
		},
		[setElements, fps],
	);

	// hover 时设置预览时间（临时）
	const handleMouseMove = useCallback(
		(e: React.MouseEvent<HTMLDivElement>) => {
			const rect = e.currentTarget.getBoundingClientRect();
			lastHoverRef.current = {
				clientX: e.clientX,
				clientY: e.clientY,
				rectLeft: rect.left,
				rectRight: rect.right,
				rectTop: rect.top,
				rectBottom: rect.bottom,
			};
			if (isPlaying || isDragging || isSelectingRef.current) return;
			const x = e.clientX - rect.left;
			const time = clampFrame(
				(x - leftColumnWidth - timelinePaddingLeft + scrollLeft) / ratio,
			);
			startTransition(() => {
				setPreviewTime(time);
			});
		},
		[ratio, scrollLeft, leftColumnWidth, isPlaying, isDragging, setPreviewTime],
	);

	// 点击时设置固定时间，并清除选中状态
	const handleClick = useCallback(
		(e: React.MouseEvent<HTMLDivElement>) => {
			if (
				selectionRect.visible &&
				selectionRect.x1 !== selectionRect.x2 &&
				selectionRect.y1 !== selectionRect.y2
			) {
				return;
			}
			const x = e.clientX - e.currentTarget.getBoundingClientRect().left;
			const time = clampFrame(
				(x - leftColumnWidth - timelinePaddingLeft + scrollLeft) / ratio,
			);
			setCurrentTime(time);
			setPreviewTime(null); // 清除预览时间
			deselectAll(); // 清除选中状态
		},
		[
			ratio,
			scrollLeft,
			leftColumnWidth,
			timelinePaddingLeft,
			setCurrentTime,
			setPreviewTime,
			deselectAll,
			selectionRect,
		],
	);

	// 鼠标离开时清除预览时间，回到固定时间
	const handleMouseLeave = useCallback(() => {
		lastHoverRef.current = null;
		setPreviewTime(null);
	}, [setPreviewTime]);

	const handleSelectionMouseDown = useCallback(
		(e: React.MouseEvent<HTMLDivElement>) => {
			if (e.button !== 0) return;
			const target = e.target as HTMLElement;
			if (target.closest("[data-timeline-element]")) {
				return;
			}

			const container = scrollAreaRef.current;
			if (!container) return;
			const rect = container.getBoundingClientRect();

			isSelectingRef.current = true;
			selectionAdditiveRef.current = e.shiftKey || e.ctrlKey || e.metaKey;
			initialSelectedIdsRef.current = selectedIds;
			setPreviewTime(null);

			const x = e.clientX - rect.left;
			const y = e.clientY - rect.top;
			const nextRect = {
				visible: true,
				x1: x,
				y1: y,
				x2: x,
				y2: y,
			};
			selectionRectRef.current = nextRect;
			setSelectionRect(nextRect);
		},
		[selectedIds, setPreviewTime],
	);

	useEffect(() => {
		if (selectionRect.visible) {
			setPreviewTime(null);
		}
	}, [selectionRect.visible, setPreviewTime]);

	useEffect(() => {
		if (wasDraggingRef.current && !isDragging && !isPlaying) {
			const lastHover = lastHoverRef.current;
			if (lastHover) {
				const isInside =
					lastHover.clientX >= lastHover.rectLeft &&
					lastHover.clientX <= lastHover.rectRight &&
					lastHover.clientY >= lastHover.rectTop &&
					lastHover.clientY <= lastHover.rectBottom;
				if (isInside && !isSelectingRef.current) {
					const x = lastHover.clientX - lastHover.rectLeft;
					const time = clampFrame(
						(x - leftColumnWidth - timelinePaddingLeft + scrollLeft) / ratio,
					);
					setPreviewTime(time);
				}
			}
		}
		wasDraggingRef.current = isDragging;
	}, [
		isDragging,
		isPlaying,
		leftColumnWidth,
		ratio,
		scrollLeft,
		timelinePaddingLeft,
		setPreviewTime,
	]);

	const computeSelectionInRect = useCallback(
		(rect: { x1: number; y1: number; x2: number; y2: number }) => {
			const container = scrollAreaRef.current;
			if (!container) return [];
			const containerRect = container.getBoundingClientRect();
			const selBox = {
				x: Math.min(rect.x1, rect.x2),
				y: Math.min(rect.y1, rect.y2),
				width: Math.abs(rect.x2 - rect.x1),
				height: Math.abs(rect.y2 - rect.y1),
			};

			const elementsInDom = Array.from(
				container.querySelectorAll<HTMLElement>("[data-timeline-element]"),
			);
			const selected: string[] = [];
			for (const el of elementsInDom) {
				const elRect = el.getBoundingClientRect();
				const elBox = {
					x: elRect.left - containerRect.left,
					y: elRect.top - containerRect.top,
					width: elRect.width,
					height: elRect.height,
				};

				if (
					selBox.x < elBox.x + elBox.width &&
					selBox.x + selBox.width > elBox.x &&
					selBox.y < elBox.y + elBox.height &&
					selBox.y + selBox.height > elBox.y
				) {
					const elementId = el.dataset.elementId;
					if (elementId) {
						selected.push(elementId);
					}
				}
			}

			return selected;
		},
		[],
	);

	const applyMarqueeSelection = useCallback(
		(nextRect: { x1: number; y1: number; x2: number; y2: number }) => {
			const selected = computeSelectionInRect(nextRect);
			if (selectionAdditiveRef.current) {
				const merged = Array.from(
					new Set([...initialSelectedIdsRef.current, ...selected]),
				);
				const primary =
					selected[selected.length - 1] ??
					initialSelectedIdsRef.current[0] ??
					null;
				setSelection(merged, primary);
			} else {
				setSelection(selected, selected[0] ?? null);
			}
		},
		[computeSelectionInRect, setSelection],
	);

	const handleSelectionMouseMove = useCallback(
		(e: React.MouseEvent<HTMLDivElement>) => {
			if (!isSelectingRef.current) return;
			const container = scrollAreaRef.current;
			if (!container) return;
			const rect = container.getBoundingClientRect();
			const x = e.clientX - rect.left;
			const y = e.clientY - rect.top;
			const nextRect = {
				...selectionRectRef.current,
				x2: x,
				y2: y,
			};
			selectionRectRef.current = nextRect;
			setSelectionRect(nextRect);
			applyMarqueeSelection(nextRect);
		},
		[applyMarqueeSelection],
	);

	const handleSelectionMouseUp = useCallback(() => {
		if (!isSelectingRef.current) return;
		isSelectingRef.current = false;

		setTimeout(() => {
			setSelectionRect((prev) => ({ ...prev, visible: false }));
		}, 0);

		applyMarqueeSelection(selectionRectRef.current);
	}, [applyMarqueeSelection]);

	useEffect(() => {
		const handleWindowMouseUp = () => {
			handleSelectionMouseUp();
		};
		window.addEventListener("mouseup", handleWindowMouseUp);
		return () => {
			window.removeEventListener("mouseup", handleWindowMouseUp);
		};
	}, [handleSelectionMouseUp]);

	// 同步 scrollLeft 到 ref
	useEffect(() => {
		scrollLeftRef.current = scrollLeft;
	}, [scrollLeft]);

	// 使用原生事件监听器来正确处理滚动，防止触发窗口滚动
	useEffect(() => {
		const scrollArea = scrollAreaRef.current;
		if (!scrollArea) return;

		const handleWheel = (e: WheelEvent) => {
			// 只在有水平滚动时才处理，垂直滚动不处理
			if (Math.abs(e.deltaX) > 0) {
				// 阻止水平滚动事件的默认行为，防止触发窗口滚动
				e.preventDefault();
				e.stopPropagation();

				// 修复方向：向右滚动（deltaX > 0）应该增加 scrollLeft
				const currentScrollLeft = useTimelineStore.getState().scrollLeft;
				const newScrollLeft = Math.max(0, currentScrollLeft + e.deltaX);
				setScrollLeft(newScrollLeft);
			}
			// 如果是纯垂直滚动（只有 deltaY），不阻止默认行为，让页面正常滚动
		};

		// 阻止触摸手势（防止后退）
		const handleTouchStart = (e: TouchEvent) => {
			if (e.touches.length === 1) {
				const touch = e.touches[0];
				const rect = scrollArea.getBoundingClientRect();
				// 如果触摸点在容器内，阻止默认行为（防止后退手势）
				if (
					touch.clientX >= rect.left &&
					touch.clientX <= rect.right &&
					touch.clientY >= rect.top &&
					touch.clientY <= rect.bottom
				) {
					e.preventDefault();
					e.stopPropagation();
					touchStartXRef.current = touch.clientX;
				}
			}
		};

		const handleTouchMove = (e: TouchEvent) => {
			if (e.touches.length === 1) {
				e.preventDefault();
				e.stopPropagation();
				const touch = e.touches[0];
				const deltaX = touchStartXRef.current - touch.clientX;
				setScrollLeft(Math.max(0, scrollLeftRef.current + deltaX));
			}
		};

		// 使用 { passive: false } 来确保可以调用 preventDefault
		scrollArea.addEventListener("wheel", handleWheel, { passive: false });
		scrollArea.addEventListener("touchstart", handleTouchStart, {
			passive: false,
		});
		scrollArea.addEventListener("touchmove", handleTouchMove, {
			passive: false,
		});

		return () => {
			scrollArea.removeEventListener("wheel", handleWheel);
			scrollArea.removeEventListener("touchstart", handleTouchStart);
			scrollArea.removeEventListener("touchmove", handleTouchMove);
		};
	}, []);

	// 自动滚动效果（拖拽到边缘时触发）
	useEffect(() => {
		if (autoScrollSpeed === 0) return;

		let animationFrameId: number;

		const animate = () => {
			const currentScrollLeft = useTimelineStore.getState().scrollLeft;
			const newScrollLeft = Math.max(0, currentScrollLeft + autoScrollSpeed);
			setScrollLeft(newScrollLeft);
			animationFrameId = requestAnimationFrame(animate);
		};

		animationFrameId = requestAnimationFrame(animate);

		return () => {
			cancelAnimationFrame(animationFrameId);
		};
	}, [autoScrollSpeed, setScrollLeft]);

	// 垂直自动滚动效果（拖拽到上下边缘时触发）
	useEffect(() => {
		if (autoScrollSpeedY === 0) return;

		const scrollContainer = verticalScrollRef.current;
		if (!scrollContainer) return;

		let animationFrameId: number;

		const animate = () => {
			const currentScrollTop = scrollContainer.scrollTop;
			const maxScrollTop =
				scrollContainer.scrollHeight - scrollContainer.clientHeight;
			const newScrollTop = Math.max(
				0,
				Math.min(maxScrollTop, currentScrollTop + autoScrollSpeedY),
			);
			scrollContainer.scrollTop = newScrollTop;
			animationFrameId = requestAnimationFrame(animate);
		};

		animationFrameId = requestAnimationFrame(animate);

		return () => {
			cancelAnimationFrame(animationFrameId);
		};
	}, [autoScrollSpeedY]);

	// 素材库拖拽时的水平自动滚动
	useEffect(() => {
		if (globalAutoScrollSpeedX === 0) return;

		let animationFrameId: number;

		const animate = () => {
			const currentScrollLeft = useTimelineStore.getState().scrollLeft;
			const newScrollLeft = Math.max(
				0,
				currentScrollLeft + globalAutoScrollSpeedX,
			);
			setScrollLeft(newScrollLeft);
			animationFrameId = requestAnimationFrame(animate);
		};

		animationFrameId = requestAnimationFrame(animate);

		return () => {
			cancelAnimationFrame(animationFrameId);
		};
	}, [globalAutoScrollSpeedX, setScrollLeft]);

	// 素材库拖拽时的垂直自动滚动
	useEffect(() => {
		if (globalAutoScrollSpeedY === 0) return;

		const scrollContainer = verticalScrollRef.current;
		if (!scrollContainer) return;

		let animationFrameId: number;

		const animate = () => {
			const currentScrollTop = scrollContainer.scrollTop;
			const maxScrollTop =
				scrollContainer.scrollHeight - scrollContainer.clientHeight;
			const newScrollTop = Math.max(
				0,
				Math.min(maxScrollTop, currentScrollTop + globalAutoScrollSpeedY),
			);
			scrollContainer.scrollTop = newScrollTop;
			animationFrameId = requestAnimationFrame(animate);
		};

		animationFrameId = requestAnimationFrame(animate);

		return () => {
			cancelAnimationFrame(animationFrameId);
		};
	}, [globalAutoScrollSpeedY]);

	const trackLayout = useMemo(() => {
		return buildTrackLayout(elements, trackAssignments);
	}, [elements, trackAssignments]);

	const trackLayoutByIndex = useMemo(() => {
		const map = new Map<number, (typeof trackLayout)[number]>();
		for (const item of trackLayout) {
			map.set(item.index, item);
		}
		return map;
	}, [trackLayout]);

	const otherTrackLayout = useMemo(() => {
		return trackLayout.filter((item) => item.index > 0);
	}, [trackLayout]);

	const otherTrackHeights = useMemo(() => {
		return otherTrackLayout.map((item) => item.height);
	}, [otherTrackLayout]);

	const otherTracksHeight = useMemo(() => {
		return otherTrackLayout.reduce((sum, item) => sum + item.height, 0);
	}, [otherTrackLayout]);
	const mainTrackHeight = useMemo(() => {
		return trackLayoutByIndex.get(0)?.height ?? getTrackHeightByRole("clip");
	}, [trackLayoutByIndex]);
	const selectionBox = useMemo(() => {
		if (!selectionRect.visible) return null;
		const x = Math.min(selectionRect.x1, selectionRect.x2);
		const y = Math.min(selectionRect.y1, selectionRect.y2);
		const width = Math.abs(selectionRect.x2 - selectionRect.x1);
		const height = Math.abs(selectionRect.y2 - selectionRect.y1);
		return { x, y, width, height };
	}, [selectionRect]);

	const timeStamps = useMemo(() => {
		return (
			<div
				key="time-stamps"
				className="sticky top-0 left-0 z-60"
				onMouseMove={handleMouseMove}
				onClick={handleClick}
				onMouseLeave={handleMouseLeave}
			>
				<div className="flex bg-neutral-800/10 border border-white/10 rounded-full mx-4 backdrop-blur-2xl overflow-hidden">
					<div
						className="border-r border-white/10"
						style={{ width: leftColumnWidth - 16 - 1 }}
					>
						<div className="h-full text-[11px] flex items-center justify-end pr-6 font-mono text-neutral-300">
							{formatTimecode(currentTime, fps)}
						</div>
					</div>
					<div
						ref={rulerContainerRef}
						className="overflow-hidden bg-neutral-800/30 flex-1"
					>
						<TimelineRuler
							scrollLeft={scrollLeft}
							ratio={ratio}
							width={rulerWidth}
							paddingLeft={timelinePaddingLeft}
							fps={fps}
						/>
					</div>
				</div>
			</div>
		);
	}, [
		handleMouseMove,
		handleClick,
		leftColumnWidth,
		currentTime,
		fps,
		scrollLeft,
		ratio,
		rulerWidth,
		timelinePaddingLeft,
	]);

	// 分离主轨道元素和其他轨道元素
	const { mainTrackElements, otherTrackElements } = useMemo(() => {
		const main: typeof elements = [];
		const other: typeof elements = [];
		for (const element of elements) {
			const trackIndex = trackAssignments.get(element.id) ?? 0;
			if (trackIndex === 0) {
				main.push(element);
			} else {
				other.push(element);
			}
		}
		return { mainTrackElements: main, otherTrackElements: other };
	}, [elements, trackAssignments]);

	// 其他轨道数量（不包括主轨道）
	const otherTrackCount = Math.max(trackCount - 1, 0);

	// 其他轨道的时间线项目
	const otherTimelineItems = useMemo(() => {
		if (otherTrackCount === 0) return null;

		const containerHeight = otherTracksHeight;

		return (
			<div
				className="relative"
				style={{
					transform: `translateX(-${scrollLeft}px)`,
					height: containerHeight,
				}}
			>
				{otherTrackElements.map((element) => {
					const trackIndex = trackAssignments.get(element.id) ?? 0;
					const layoutItem = trackLayoutByIndex.get(trackIndex);
					const y = layoutItem?.y ?? 0;
					const elementTrackHeight =
						layoutItem?.height ?? getTrackHeightByRole("overlay");
					return (
						<TimelineElement
							key={element.id}
							element={element}
							trackIndex={trackIndex}
							trackY={y}
							ratio={ratio}
							trackHeight={elementTrackHeight}
							trackCount={trackCount}
							updateTimeRange={updateTimeRange}
						/>
					);
				})}
			</div>
		);
	}, [
		otherTrackElements,
		scrollLeft,
		ratio,
		updateTimeRange,
		trackAssignments,
		trackCount,
		otherTrackCount,
		otherTracksHeight,
		trackLayoutByIndex,
	]);

	// 主轨道的时间线项目
	const mainTimelineItems = useMemo(() => {
		// 主轨道在整体布局中的 Y 坐标（用于拖拽计算）
		const mainTrackYInGlobalLayout =
			trackLayoutByIndex.get(0)?.y ?? otherTracksHeight;

		return (
			<div
				className="relative"
				style={{
					transform: `translateX(-${scrollLeft}px)`,
					height: mainTrackHeight,
				}}
			>
				{mainTrackElements.map((element) => {
					return (
						<TimelineElement
							key={element.id}
							element={element}
							trackIndex={0}
							trackY={mainTrackYInGlobalLayout}
							ratio={ratio}
							trackHeight={mainTrackHeight}
							trackCount={trackCount}
							updateTimeRange={updateTimeRange}
						/>
					);
				})}
			</div>
		);
	}, [
		mainTrackElements,
		scrollLeft,
		ratio,
		updateTimeRange,
		trackCount,
		trackLayoutByIndex,
		otherTracksHeight,
		mainTrackHeight,
	]);

	// 其他轨道标签（不包括主轨道）
	const otherTrackLabels = useMemo(() => {
		if (otherTrackCount === 0) return null;
		return otherTrackLayout.map((item) => (
			<div
				key={item.index}
				className="flex items-center justify-end pr-3 text-xs font-medium text-neutral-400"
				style={{ height: item.height }}
			>
				{`轨道 ${item.role}`}
			</div>
		));
	}, [otherTrackCount, otherTrackLayout]);

	// 主轨道标签
	const mainTrackLabel = useMemo(() => {
		return (
			<div
				className="flex items-center justify-end pr-3 text-xs font-medium text-blue-400"
				style={{ height: mainTrackHeight }}
			>
				主轨道
			</div>
		);
	}, [mainTrackHeight]);

	// 吸附指示线
	const snapIndicator = useMemo(() => {
		if (!activeSnapPoint || otherTrackCount === 0) return null;
		const left = activeSnapPoint.time * ratio - scrollLeft;
		return (
			<div
				className="absolute top-12 bottom-0 w-px bg-green-500 pointer-events-none"
				style={{ left: left + timelinePaddingLeft }}
			/>
		);
	}, [
		activeSnapPoint,
		ratio,
		scrollLeft,
		otherTrackCount,
		timelinePaddingLeft,
	]);

	return (
		<div
			className="relative bg-neutral-800 h-full flex flex-col min-h-0 w-full overflow-hidden"
			onMouseLeave={handleMouseLeave}
		>
			<div className="pointer-events-none absolute top-0 left-0 w-full h-19 z-50 bg-linear-to-b from-neutral-800 via-neutral-800 via-70% to-transparent"></div>
			<ProgressiveBlur
				position="top"
				className="absolute top-0 w-full h-20 z-60 "
				blurLevels={[0.5, 4, 16, 16, 16, 16, 16, 16]}
			/>
			<TimelineToolbar className="h-12 z-60" />
			{timeStamps}
			<div
				ref={scrollAreaRef}
				data-timeline-scroll-area
				className="relative w-full flex-1 min-h-0 flex flex-col -mt-18 overflow-hidden"
				onMouseMove={(e) => {
					handleMouseMove(e);
					handleSelectionMouseMove(e);
				}}
				onMouseDown={handleSelectionMouseDown}
				onMouseUp={handleSelectionMouseUp}
				onMouseLeave={handleMouseLeave}
				onClick={handleClick}
			>
				{selectionBox && selectionBox.width > 0 && selectionBox.height > 0 && (
					<div
						className="absolute border z-70 border-blue-500/80 bg-blue-500/10 pointer-events-none"
						style={{
							left: selectionBox.x,
							top: selectionBox.y,
							width: selectionBox.width,
							height: selectionBox.height,
						}}
					/>
				)}
				<div
					className="h-full w-full absolute top-0 left-0 pointer-events-none z-60"
					style={{ marginLeft: leftColumnWidth }}
				>
					<TimeIndicatorCanvas
						className="top-12 z-50"
						leftOffset={timelinePaddingLeft}
						ratio={ratio}
						scrollLeft={scrollLeft}
					/>
				</div>
				<div
					className="h-full w-full absolute top-0 left-0 pointer-events-none z-50"
					style={{ marginLeft: leftColumnWidth }}
				>
					{snapIndicator}
				</div>

				{/* 轨道区域（可滚动） */}
				<div
					ref={verticalScrollRef}
					data-vertical-scroll-area
					className="w-full flex-1 min-h-0 overflow-y-auto"
				>
					<div className="relative flex flex-col min-h-full">
						<div
							className="z-10 absolute left-0 top-0 h-full pointer-events-none bg-neutral-800/80 backdrop-blur-3xl backdrop-saturate-150 border-r border-white/10"
							style={{ width: leftColumnWidth }}
						></div>
						{/* 其他轨道区域 */}
						<div className="flex flex-1 mt-18">
							{/* 左侧列，其他轨道标签 */}
							<div
								className="text-white z-10 pr-4 flex flex-col"
								style={{ width: leftColumnWidth }}
							>
								<div className="flex-1 flex flex-col justify-end">
									<div className="mt-1.5">{otherTrackLabels}</div>
								</div>
							</div>
							{/* 右侧其他轨道时间线内容 */}
							<div
								ref={containerRef}
								data-track-drop-zone="other"
								data-track-count={otherTrackCount}
								data-track-heights={otherTrackHeights.join(",")}
								className="relative flex-1 overflow-x-hidden pt-1.5 flex flex-col justify-end"
								style={{
									paddingLeft: leftColumnWidth,
									marginLeft: -leftColumnWidth,
								}}
							>
								<div style={{ paddingLeft: timelinePaddingLeft }}>
									<div
										className="relative"
										data-track-content-area="other"
										data-content-height={otherTracksHeight}
									>
										{otherTimelineItems}
									</div>
								</div>
							</div>
						</div>
						{/* 主轨道区域（sticky 底部） */}
						<div className="z-10 flex items-start border-t border-b border-white/10 sticky bottom-0 *:pt-1.5">
							{/* 左侧主轨道标签 */}
							<div
								className="text-white z-10 pr-4 flex flex-col bg-neutral-900/90 backdrop-blur-2xl border-r border-white/10"
								style={{ width: leftColumnWidth }}
							>
								{mainTrackLabel}
							</div>
							{/* 右侧主轨道时间线内容 */}
							<div
								data-track-drop-zone="main"
								data-track-index="0"
								className="relative flex-1 overflow-x-hidden bg-neutral-900/90 backdrop-blur-2xl"
								onMouseMove={handleMouseMove}
								onMouseLeave={handleMouseLeave}
								onClick={handleClick}
								style={{
									paddingLeft: leftColumnWidth,
									marginLeft: -leftColumnWidth,
								}}
							>
								<div style={{ paddingLeft: timelinePaddingLeft }}>
									<div className="relative" data-track-content-area="main">
										{mainTimelineItems}
									</div>
								</div>
							</div>
						</div>
						{/* 音频轨道区域 */}
						<div className="z-10 flex-1">
							{/* 左侧音频轨道标签 */}
							<div
								className="h-full text-white pr-4 flex flex-col z-10"
								style={{ width: leftColumnWidth }}
							>
								{/* <div className="h-12 flex items-center justify-end pr-3 text-xs font-medium text-neutral-400">
									音频轨道
								</div> */}
							</div>
							{/* TODO: 右侧音频轨道时间线内容 */}
						</div>
					</div>
				</div>
				{/* 拖拽 Ghost 层 */}
				<TimelineDragOverlay
					activeDropTarget={activeDropTarget}
					dragGhosts={dragGhosts}
					ratio={ratio}
					scrollLeft={scrollLeft}
					otherTrackCount={otherTrackCount}
					otherTrackHeights={otherTrackHeights}
					mainTrackHeight={mainTrackHeight}
					timelinePaddingLeft={timelinePaddingLeft}
				/>
			</div>
		</div>
	);
};

export default TimelineEditor;
